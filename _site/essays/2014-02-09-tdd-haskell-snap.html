<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>dbpmail.net :: TDD with Haskell and the Snap Web Framework</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>
        <div id="navigation">
            <a href="http://dbpmail.net">dbpmail.net</a>
            <a href="#" title="site created with hakyll, http://jaspervdj.be/hakyll/">::</a>
            <a href="../index.html">About</a>
            <a href="../essays.html">Essays</a>
            <a href="../reading.html">Reading</a>
            <a href="../projects.html">Projects</a>
            <a href="http://photo.dbpmail.net">Photos</a>
        </div>
        <h2>TDD with Haskell and the Snap Web Framework</h2>

<p>by <em>Daniel Patterson</em> on <strong>February  9, 2014</strong></p>

<p>Test driven development is nothing new - people have been talking about it in various forms for at least 14 years<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>. Within the web development community, it is used most pervasively in dynamic languages, with Ruby probably being the best example, both in quality of libraries and pervasive use. And with good reason - without tests you really have no idea if the changes you’ve made have just broken your whole site. However, when I’m writing tests for Ruby code, most of what I’m writing is covering a lot more than just types, so while there are certainly lots of bugs that Haskell’s type system catches, types don’t catch everything. So I’m announcing a library that should make it a lot easier to write tests with Haskell and the Snap web framework - tests that involve the database, web requests, etc. The general design is inspired by RSpec, and the library is available on hackage at <a href="http://hackage.haskell.org/package/snap-testing">http://hackage.haskell.org/package/snap-testing</a>.</p>
<h3 id="examples-and-preview-of-use">Examples and preview of use</h3>
<p>Here are a few basic tests:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">name <span class="st">&quot;/ success&quot;</span> <span class="fu">$</span>
  succeeds (get <span class="st">&quot;/&quot;</span>)
name <span class="st">&quot;/foo/bar not found&quot;</span> <span class="fu">$</span>
  notfound (get <span class="st">&quot;/foo/bar&quot;</span>)</code></pre>
<p>The tests are hierarchical, with (optional) names on the nodes of the tree. There are simple functions to check against status codes, modification of state, response bodies, etc. For a more complicated example, consider:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">name <span class="st">&quot;/auth/new_user&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
  name <span class="st">&quot;success&quot;</span> <span class="fu">$</span>
    succeeds (get <span class="st">&quot;/auth/new_user&quot;</span>)
  name <span class="st">&quot;creates a new account&quot;</span> <span class="fu">$</span>
    cleanup clearAccounts <span class="fu">$</span>
    changes (<span class="fu">+</span><span class="dv">1</span>) countAccounts (post <span class="st">&quot;/auth/new_user&quot;</span> <span class="fu">$</span> params
                                [ (<span class="st">&quot;new_user.name&quot;</span>, <span class="st">&quot;Jane&quot;</span>)
                                , (<span class="st">&quot;new_user.email&quot;</span>, <span class="st">&quot;jdoe@c.com&quot;</span>)
                                , (<span class="st">&quot;new_user.password&quot;</span>, <span class="st">&quot;foobar&quot;</span>)])</code></pre>
<p>We can also run arbitrary handlers to get data that is used later on in tests, like:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">token <span class="ot">&lt;-</span> fmap fromJust <span class="fu">$</span> eval (newToken site)
<span class="fu">...</span>
eval (invalidateToken token)
name <span class="st">&quot;should not show invalidated tokens&quot;</span> <span class="fu">$</span>
  notcontains (get site_url) (tokenText token)</code></pre>
<p>Finally, it is (relatively) easy to add new utilities. For example, we can write an application specific utility (in my case, users have both a auth snaplet <code>AuthUser</code> and an application specific <code>Account</code>) to create a new user and log in as them:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">withUser ::</span> <span class="dt">SnapTesting</span> <span class="dt">App</span> a <span class="ot">-&gt;</span> <span class="dt">SnapTesting</span> <span class="dt">App</span> a
withUser <span class="fu">=</span> modifySite <span class="fu">$</span> \site <span class="ot">-&gt;</span> <span class="kw">do</span>
  (_, au) <span class="ot">&lt;-</span> fmap fromJust getRandomUser
  with auth <span class="fu">$</span> forceLogin au
  site</code></pre>
<p>Where <code>getRandomUser</code> is a helper with signature:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">getRandomUser ::</span> <span class="dt">AppHandler</span> (<span class="dt">Maybe</span> (<span class="dt">Account</span>, <span class="dt">AuthUser</span>))</code></pre>
<p>We can also get the random user using <code>eval</code> (shown above with the <code>token</code>) and then use that later with a helper like this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">loginAs ::</span> <span class="dt">AuthUser</span> <span class="ot">-&gt;</span> <span class="dt">SnapTesting</span> <span class="dt">App</span> a <span class="ot">-&gt;</span> <span class="dt">SnapTesting</span> <span class="dt">App</span> a
loginAs au <span class="fu">=</span> modifySite <span class="fu">$</span> \site <span class="ot">-&gt;</span> <span class="kw">do</span>
  with auth <span class="fu">$</span> forceLogin au
  site</code></pre>
<p>For example:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">loginAs user <span class="fu">$</span> <span class="kw">do</span>
  name <span class="st">&quot;success with right login&quot;</span> <span class="fu">$</span>
    succeeds (get site_url)
  name <span class="st">&quot;has site name in response&quot;</span> <span class="fu">$</span>
    contains (get site_url) <span class="st">&quot;Some Site&quot;</span>
  name <span class="st">&quot;/edit displays a page with a form on it&quot;</span> <span class="fu">$</span>
    contains (get <span class="fu">$</span> B.append site_url <span class="st">&quot;/edit&quot;</span>) <span class="st">&quot;&lt;form&quot;</span></code></pre>
<p>There are multiple possible report generators (and it is easy to write more) - currently two in the library - a report of the tree of tests printed to the console, and one that uses linux’s desktop-notification protocol to display whether the tests passed or failed (with counts). The console one looks like:</p>
<pre><code>/ success
  PASSED
/foo/bar not found
  PASSED
/auth/new_user
  success
    PASSED
  creates a new account
    PASSED
...</code></pre>
<h3 id="api-description">API description</h3>
<p>All the tests are run in the <code>SnapTesting</code> monad, which takes two parameters - one being what is usually called <code>App</code> - the main datastructure with the application state, and the second being the current value. To run tests, use the following function:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runSnapTests ::</span> [[<span class="dt">TestResult</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()] <span class="ot">-&gt;</span> <span class="dt">Handler</span> b b ()
             <span class="ot">-&gt;</span> <span class="dt">SnapletInit</span> b b <span class="ot">-&gt;</span> <span class="dt">SnapTesting</span> b () <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</code></pre>
<p>This is a big signature, but easy to piece apart. The first argument is a list of repart generators - they take a list of <code>TestResult</code> and do something with them. <code>TestResult</code> is defined as:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">TestResult</span> <span class="fu">=</span> <span class="dt">ResultName</span> <span class="dt">Text</span> [<span class="dt">TestResult</span>] <span class="fu">|</span> <span class="dt">ResultPass</span> <span class="dt">Text</span> <span class="fu">|</span> <span class="dt">ResultFail</span> <span class="dt">Text</span></code></pre>
<p>The second argument is the top level handler that all requests will be run against. It can be any handler, but it should probably be something like <code>route routes</code>, where <code>routes</code> is what you pass to <code>addRoutes</code> in your initializer. The third argument is the initializer for your application, and the final argument is the test block. Putting it all together, we get something like:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> runSnapTests [consoleReport, linuxDesktopReport] (route routes) app <span class="fu">$</span> <span class="kw">do</span>
  name <span class="st">&quot;/ success&quot;</span> <span class="fu">$</span>
    succeeds (get <span class="st">&quot;/&quot;</span>)
  name <span class="st">&quot;/foo/bar not found&quot;</span> <span class="fu">$</span>
    notfound (get <span class="st">&quot;/foo/bar&quot;</span>)
<span class="fu">...</span></code></pre>
<p>Which we can put in a file like <code>Test.hs</code> and run with runghc.</p>
<p>There are many functions you can use in a <code>SnapTesting</code> block. You can look at the docs for signatures, or above for uses, but brief descriptions are:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">name <span class="co">-- add a named node to the test tree</span>
succeeds <span class="co">-- assert that the given request (built by get or post) succeeds</span>
notfound <span class="co">-- assert request 404s</span>
redirects <span class="co">-- assert request redirects (status 3XX)</span>
redirectsto <span class="co">-- assert request redirects to specific url</span>
changes <span class="co">-- given a predicate and a monadic value, check difference before and after running request</span>
contains <span class="co">-- assert response contains regular expression</span>
notcontains <span class="co">-- assert response does not contain regular expression</span>
cleanup <span class="co">-- run an action after a test block</span>
eval <span class="co">-- evaluate an action, returning the value</span></code></pre>
<p>Further, there are a couple functions for building requests:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">get <span class="co">-- creates a get request, given a url (no params)</span>
post <span class="co">-- creates a post request, given a url and params map</span>
params <span class="co">-- helper to turn tupled list into params map</span></code></pre>
<p>And finally a helper for writing new utilities, that allows you to modify the top level handler (the entire site, essentially) for a block:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">modifySite</code></pre>
<h3 id="future-improvements">Future Improvements</h3>
<p>There are two major things that I’d like to improve:</p>
<ul>
<li>The first is to print reports incrementally, not just at the end.</li>
<li>The second is to not pay the initialization cost for each request. Right now, the snaplet testing api (what this library uses) is designed to take an initializer and an action, and it runs the initializer and then the action. Ideally, this could be separated, as especially with sites with lots of templates, initialization takes a non-trivial amount of time.</li>
</ul>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Extreme programming was published in 1999, giving a lower bound on the age.<a href="#fnref1">↩</a></p></li>
</ol>
</div>

        <div id="footer">
            last modified: <a href="http://hub.darcs.net/dbp/dbpmail/changes">February 10, 2014</a> | <a href="../rss.xml">rss feed</a>
        </div>
    </body>
</html>
